(slice) get_address () asm "MYADDR";
(int, int) parse_address (slice) asm "REWRITESTDADDR";

(int, cell, int, cell, cell) load_data () inline {
  var cs = get_data().begin_parse();
  (int init, 
   cell balances, 
   int fee_per_send, 
   cell pending_queries,
   cell description) = (cs~load_int(1), 
                        cs~load_dict(), 
                        cs~load_grams(), 
                        cs~load_dict(),
                        cs~load_ref());
  return (init, balances, fee_per_send, pending_queries); 
}

() save_data (cell balances, int fee_per_send, cell pending_queries, cell description) impure inline {
  cell storage = begin_cell().store_int(-1, 1)
                             .store_dict(balances)
                             .store_grams(fee_per_send)
                             .store_dict(pending_queries)
                             .store_ref(description)
                 .end_cell();
  set_data(storage);
}

int get_uniq_token () inline {
  ;; TODO problem with this way of uniq_token calculation
  ;; is that for contracts on different workchains but with
  ;; the same address it gives the same token.
  ;; Probably slice_hash(get_address())>>192 should be used instead
  ;; Gas price should be checked as well, may be it is cheaper
  ;; to load/store uniq_token
  (int wc, int hsh) = parse_address(get_address());
  return (hsh >> 192);
}

(cell, ()) ~remember_query(cell pending_queries, int query_id) inline {
  pending_queries~udict_set_builder(64, query_id, begin_cell());
  return (pending_queries, ());
}

(cell, (int)) ~clean_expired_queries(cell pending_queries, int bound) inline {
  bound -= (64 << 32);   ;; clean up records expired more than 64 seconds ago
  int need_save = 0;
  do {
    var (pending_queries', i, _, f) = pending_queries.udict_delete_get_min(64);
    f~touch();
    if (f) {
      f = (i < bound);
    }
    if (f) {
      pending_queries = pending_queries';
      need_save = -1;
    }
  } until (~ f);
  return (pending_queries, (need_save));
}

(cell, ()) ~decrease_balance(cell balances, int user_id, int amount) inline {
  (slice user_balance_cell, int user_found) = balances~udict_delete_get?(256, user_id);
  throw_unless(41, user_found);
  int balance = user_balance_cell~load_grams();
  ;; throw_if(42, balance < amount); useless since if final balance less than 0 exception during grams storing will be raised
  balance -= amount;
  if(balance) {
    balances~udict_set_builder(256, user_id, begin_cell().store_grams(balance));
  }
  return (balances, ());
}

(cell, ()) ~increase_balance(cell balances, int user_id, int amount) inline {
  (slice user_balance_cell, int user_found) = balances.udict_get?(256, user_id);
  if(user_found) {
    int balance = user_balance_cell~load_grams();
    amount += balance;
    ;; throw_if(46, new_payee_balance > 18446744073709551615); useless since if final balance higher than 2^120 exception during grams storing will be raised
  }
  if(amount) {
    balances~udict_set_builder(256, user_id, begin_cell().store_grams(amount));
  }
  return (balances, ());
}

() recv_external (slice in_msg) {
  (int init, cell balances, int fee_per_send, cell pending_queries, cell description) = load_data();
  ifnot(init) {
    accept_message();
    save_data(balances, fee_per_send, pending_queries);
    return ();
  }
  slice signature = in_msg~load_bits(512);
  slice cs = in_msg;
  (int query_id, int op, int pubkey, int uniq_token) = (cs~load_uint(64), cs~load_uint(8), cs~load_uint(256), cs~load_uint(64));
  var bound = (now() << 32);
  throw_if(33, query_id < bound);  
  throw_if(35, query_id > (bound + 281474976710656)); ;; Do not process orders which should be stored too long
  ;; 281474976710656 = 2**48 = 65536 * 2**32 ~ 18 hours

  int order_hash = slice_hash(in_msg);
  throw_unless(34, check_signature(order_hash, signature, pubkey));
  throw_unless(44, uniq_token == get_uniq_token());  
  (_, int has_query) = pending_queries.udict_get?(64, query_id);
  throw_if(47, has_query);
  if( op == 0 ) { ;; simple send
    int sender_id = pubkey; ;; just alias
    cs = cs~load_ref().begin_parse();
    (int amount, int payee_id) = (cs~load_grams(), cs~load_uint(256));
    balances~decrease_balance(sender_id, amount + fee_per_send);
    balances~increase_balance(payee_id, amount);
    pending_queries~remember_query(query_id);
    pending_queries~clean_expired_queries(bound);
    save_data(balances, fee_per_send, pending_queries, description);     
    accept_message();  
  }
}

() recv_internal (int msg_value, cell in_msg_cell, slice in_msg) {
;;
}

(int) balanceOf (int user_id) method_id {
  (int init, cell balances, int fee_per_send, cell pending_queries) = load_data();
  (slice user_balance_cell, int user_found) = balances.udict_get?(256, user_id);
  ifnot(user_found) {
    return 0;
  }
  return user_balance_cell~load_grams();
}
